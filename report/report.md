# bomblab 报告

姓名：卢霄羽

学号：2024201562

| 总分 | phase_1 | phase_2 | phase_3 | phase_4 | phase_5 | phase_6 | secret_phase |
| --------- | ------------- | ------------- | ------------- | ----------------- |-----------|-----------|-----------|
| 7       | 1            | 1            | 1            | 1 |1  |1  |1  |


scoreboard 截图：

![image](./%202025-12-19%20232427%20(1).png)

<!-- TODO: 用一个scoreboard的截图，本地图片，放到 imgs 文件夹下，不要用这个 github，pandoc 解析可能有问题 -->

## 解题报告

<!-- 对你拆掉的每个phase进行分析，并写出你得出答案的历程 -->

<!-- 如果能用伪代码还原题目源代码最佳（不属于先前提到的大段代码），语言描述自己的分析也可，每道题目的图片不建议超过两张 -->

### phase_1

```c
If abstraction is the definition of beauty, are those of us chasing after clarity a representation of ugly?
```
讲解题目思路：

我们先检查会导致爆炸的情况，发现必须让strings_not_equal函数返回0，才能避开explode_bomb

我们根据名字猜测strings_not_equal就是判断字符是否相等的函数，通过阅读代码可知，这个函数在字符串相等时返回0，不相等时返回1。那么我们应该要找到并输入程序预存好的字符串，

    1439:	48 8d 35 40 1d 00 00 	lea    0x1d40(%rip),%rsi 

这一行说明了调用函数之前，通过$ \%rsi $向其中传参，那么这个传入的参数应该就是我们接下来要进行对比的标准答案，我们通过x/s命令查看并复制这个字符串作为我们的输入，即可解除phase_1


### phase_2

```c
942994 762286 1073121 1078973
```
讲解题目思路：

    146b:	48 89 e2             	mov    %rsp,%rdx
    146e:	48 8d 4c 24 04       	lea    0x4(%rsp),%rcx
    1473:	4c 8d 4c 24 0c       	lea    0xc(%rsp),%r9
    1478:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8

这四行可知，向scanf中传入四个地址，分别存储四个输入

    147d:	48 8d 35 8d 21 00 00 	lea    0x218d(%rip),%rsi 

通过gdb打印$\%rsi$指向的字符串，发现是"%d %d %d %d"，说明输入四个整数

    1489:	83 f8 04             	cmp    $0x4,%eax
    148c:	75 14                	jne    14a2 <phase_2+0x4d>
$\%eax$是scanf的返回值，即输入的变量个数，检查其是否为4，不为4则explode_bomb

我们可以先不细究代码运算的原理，直接看引爆或者通过的条件

    150e:	48 83 c3 04          	add    $0x4,%rbx          
    1512:	48 83 fb 10          	cmp    $0x10,%rbx
    1516:	74 10                	je     1528 <phase_2+0xd3>
    1518:	8b 44 1d 00          	mov    0x0(%rbp,%rbx,1),%eax
    151c:	39 04 1c             	cmp    %eax,(%rsp,%rbx,1)
    151f:	74 ed                	je     150e <phase_2+0xb9>  # matchloop end
    1521:	e8 0a 0a 00 00       	call   1f30 <explode_bomb>

发现，这一段在循环四次地比较$\%eax$和我们存入在$\%rsp, \%rsp+4, \%rsp+8, \%rsp+12$处的数据，那么每次循环都使用gdb查看$\%eax$中的值，即可得到答案

之后我们在看看代码详细讲了什么，发现代码段中有三个jump，说明有三层嵌套循环，再根据注释 # 6130 <matA.2>  # 6110 <matB.1>可知这是一个矩阵运算，进一步分析其指针移动方式和 imul   (%rsi,%rax,8),%edx 这一句，推断出这是一个 $2*3$ 的矩阵乘以一个 $3*2$ 的矩阵，得到$2*2$的矩阵，即我们要输入的四个数

### phase_3

```c
5 -171
```

讲解题目思路:

    1561:	48 8d 35 af 20 00 00 	lea    0x20af(%rip),%rsi

先分析输入结构，查看后得知要输入两个整数a和b

    1572:	83 7c 24 04 00       	cmpl   $0x0,0x4(%rsp) # b>=0 bomb
    1577:	78 05                	js     157e <phase_3+0x3a>    
    157e:	83 3c 24 07          	cmpl   $0x7,(%rsp) # a>7 bomb
    1582:	0f 87 9a 00 00 00    	ja     1622 <phase_3+0xde>

再分析这两个数的限制，有a<=7和b<0

    1599:	ff e0                	jmp    *%rax

继续阅读发现代码会跳转，且跳转的位置与输入的a有关，会跳转到下面跳转表的某一位置，再跳转回程序的主要部分

    cmpl   $0x5,(%rsp) # a>5 bomb

又限制的a的值不能大于5

通过尝试发现，a=5时可以使%eax为负数，满足b=%eax<0的要求

故 b=-0xab=-171 可得答案

### phase_4

```c
31 CB
```
同样先分析输入要求，这里不再赘述，具体要求为2个输入，a为数字，b为字符串且长度为2

如果不细究代码在做什么，我们同样只需要通过gdb打印出最后比较的内容即可得知答案，具体在这几行

    172c:	39 44 24 0c          	cmp    %eax,0xc(%rsp) # retuen value != a bomb  a should be 31
    1768:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    176d:	48 89 de             	mov    %rbx,%rsi
    1770:	e8 56 05 00 00       	call   1ccb <strings_not_equal>

实际分析发现，fun4_1是一个递归的函数
### phase_5

```c
-12 56
```

同样先分析输入要求，这里不再赘述，具体要求为a<0

之后代码对输入进行预处理a%=16且取模后的结果不为15，将结果存入%eax

接下来进入循环，每次以当前以%rax中的只为下标，将array中的值存入%eax中
即a=array[a]，并且把加载后的值存入%ecx中，直到a=0xf=15

最后要求循环次数为8，并求出%ecx中的累加值

我们将array打印出来
![](./2025-12-04%20100517.png)
我们知道，要8步到达15，那么初始应当指向数组的第5个元素，即下标为4，又由于要求a为负数，所以取a=-12，模拟一遍即可知道加和值为56

### phase_6

```c
2 4 3 1 5 6 puzzle
```

同样先分析输入要求，这里不再赘述，具体要求为六个数

接下来通过循环检测这六个数是否各不相同

接着循环，将输入的数a[i]变为7-a[i]，即a[i]=7-a[i]

之后将node的指针存入栈中，之后调整指针，将链表重新排序，最后检测链表是否是是从大到小的顺序

    0x55555555a210 <node1>: 219
    0x55555555a220 <node2>: 332
    0x55555555a230 <node3>: 775
    0x55555555a240 <node4>: 431
    0x55555555a250 <node5>: 835
    0x55555555a160 <node6>: 376

我们打印出链表的值，将其重新排序
```c
    835 5 2
    775 3 4
    431 4 3
    376 6 1
    332 2 5 
    219 1 6
```
同时注意还原a[i]=7-a[i]的变换即可得到答案

### secret_phase

```c
cccaa
```
首先要激活secret_phase，有两个条件，第一要解出前面的六个phrase，其次还要输入指定的字符串
    
    (gdb) x/s 0x555555557661
    0x555555557661: "puzzle"

可知这个字符是puzzle，将其放在phrase_6的输入后面即可

接下来分析输入secret_phase的输入是一个长度不超过14的字符串

![](./%202025-12-19%20232427%20(2).png)
再看其配套函数func7，以及终端horse的提示，可以发现这是一个棋盘游戏，gdb打印出棋盘，从（0，0）出发找到一条可行路径cccaa即可

## 反馈/收获/感悟/总结


好玩！抽丝剥茧

<!-- 这一节，你可以简单描述你在这个 lab 上花费的时间/你认为的难度/你认为不合理的地方/你认为有趣的地方 -->

<!-- 或者是收获/感悟/总结 -->

<!-- 200 字以内，可以不写 -->

## 参考的重要资料

<!-- 有哪些文章/论文/PPT/课本对你的实现有重要启发或者帮助，或者是你直接引用了某个方法 -->

<!-- 请附上文章标题和可访问的网页路径 -->